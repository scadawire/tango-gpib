static const char *RcsId = "$Header: /users/chaize/newsvn/cvsroot/Communication/Gpib/src/GpibDeviceServer.cpp,v 1.2 2005-02-09 15:25:03 xavela Exp $";
//+=============================================================================
//
// file :         GpibDeviceServer.cpp
//
// description :  C++ source for the GpibDeviceServer and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                GpibDeviceServer are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: xavela $
//
// $Revision: 1.2 $
//
// $Log: not supported by cvs2svn $
// Revision 1.1.1.1  2004/06/30 13:52:12  syldup
// intial import from soleil
//
// Revision 1.5  2004/06/30 08:57:58  elattaoui
// xavier : ajout de #ifdef linux
// changement de #define MAX_... par const int !
//
// Revision 1.4  2004/06/29 13:32:34  elattaoui
// xavier : oubli de commandes en mode expert
// rectifie
//
// Revision 1.3  2004/06/29 10:16:09  elattaoui
// xavier : ajout du .obj dans le repertoire lib
//
// Revision 1.2  2004/06/29 10:05:59  elattaoui
// xavier : verion finale du DServer
// partage des commandes en mode Operator et
// Expert
// ajout d'un CTOR par address avec la fonction ibdev
//
// Revision 1.1.1.1  2004/02/11 09:06:06  root
// initial import
//
// Revision 1.2  2003/11/19 09:41:01  vedder
// First working version, with win32 port, with soleil.
//
// Revision 1.1.1.1  2003/10/08 09:30:46  verdier
// Imported using TkCVS
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


//===================================================================
//
//	The folowing table gives the correspondance
//	between commands and method's name.
//
//	Command's name	|	Method's name
//	----------------------------------------
//	State	|	dev_state()
//	Status	|	dev_status()
//	Write	|	write()
//	Read	|	read()
//	Close	|	close()
//	ReadLongString	|	read_long_string()
//	GetName	|	get_name()
//	Local	|	local()
//	Remote	|	remote()
//	Getiberr	|	getiberr()
//	Getibsta	|	getibsta()
//	Getibcnt	|	getibcnt()
//	Clear	|	clear()
//	SetTimeOut	|	set_time_out()
//	BCsendIFC	|	bcsend_ifc()
//	BCclr	|	bcclr()
//	GetDeviceID	|	get_device_id()
//	BCllo	|	bcllo()
//	BCcmd	|	bccmd()
//	Open	|	open()
//	OpenByName	|	open_by_name()
//	BCGetConnectedDeviceList	|	bcget_connected_device_list()
//	Trigger	|	trigger()
//	WriteRead	|	write_read()
//	Config	|	config()
//	BCConfig	|	bcconfig()
//	SendBinData	|	send_bin_data()
//	ReceiveBinData	|	receive_bin_data()
//
//===================================================================

#include <tango.h>
#include <GpibDeviceServer.h>
#include "gpibDevice.h"
#include "gpibDeviceException.h"

namespace GpibDeviceServer
{
	
//+----------------------------------------------------------------------------
//
// method : 		GpibDeviceServer::GpibDeviceServer(string &s)
// 
// description : 	constructor for simulated GpibDeviceServer
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
GpibDeviceServer::GpibDeviceServer(Tango::DeviceClass *cl,string &s):Tango::Device_2Impl(cl,s.c_str())
{
	gpib_device = NULL;	
	init_device();
}

GpibDeviceServer::GpibDeviceServer(Tango::DeviceClass *cl,const char *s):Tango::Device_2Impl(cl,s)
{
	gpib_device = NULL;	
	init_device();
}

GpibDeviceServer::GpibDeviceServer(Tango::DeviceClass *cl,const char *s,const char *d)
	:Tango::Device_2Impl(cl,s,d)
{
	gpib_device = NULL;	
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		GpibDeviceServer::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void GpibDeviceServer::delete_device()
{
	// AJOUT
	//	Delete device's allocated object
	//	delete gpib_device;
	//	gpib_device = NULL;
	// board 0 ?
	// TODO  clear & close ....
}

//+----------------------------------------------------------------------------
//
// method : 		GpibDeviceServer::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------

void GpibDeviceServer::init_device()
{
	INFO_STREAM << "GpibDeviceServer::GpibDeviceServer() create device " << device_name << endl;
	
	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();
	dev_open = false;	// No gpib device opened.
	
	try 
	{
		INFO_STREAM << "Looking for Board:" << device_name << endl;	    
	    board0 = new gpibBoard( gpibBoardName );
	    cout << "gpib board " << gpibBoardName << " has been found." << endl;
	} 
	catch (gpibDeviceException e) 
	{
		cout << "Sorry, no gpib Board found !" << endl;
		exit(-1);
	}
	
	// gpib_device is initialised in Constructor !
	if (gpib_device != NULL) 
	{
		delete gpib_device;
		gpib_device = NULL;
	}
	
	// Now try to open gpibDevice by address property; gpibDeviceAddress.
	// To check that there is a real gpib Device behind the driver name,
	// we send an isAlive command. If answer is <=0 the device is off or
	// absent.
	try 
	{
		gpib_device = new gpibDevice((int) gpibDeviceAddress, gpibBoardName);
		
		// Force exception if device not listening (Off)
		int sb = gpib_device->isAlive();
		if (sb <=0) throw gpibDeviceException((string)"",(string)"",(string)"",(string)"", 0, 0);
		gpib_device->setTimeOut(gpibDeviceTimeOut);	// Set Time Out.
		dev_open = true;
		set_state(Tango::ON);
		set_status("Gpib device is OK.");
        cout << "Device found by address ("<< gpibDeviceAddress<<")." << endl;
	} 
	catch (gpibDeviceException e) 
	{
        cout << "Cant find device by address ("<< gpibDeviceAddress<<")." << endl;
	}
	catch (...) 
	{
		cout << "UNEXPECTED EXCEPTION !!!" << endl;	
		exit(-1);
	}
	
    
	// Can't open device by address, try by name with names property; gpibDeviceName.
	if (dev_open == false) 
	{
		cout << "Trying by name:" << endl;
		
		try 
		{
			if(gpib_device != NULL) 
			{
				cout << "Before delete." << endl;
				delete gpib_device;// AJOUT
				cout << "After delete." << endl;
				gpib_device = NULL;
			}
			
			gpib_device = new gpibDevice( gpibDeviceName, gpibBoardName );
			
			// Force exception if device not listening (Off)
			int sb = gpib_device->isAlive();
			if (sb <=0) throw gpibDeviceException((string)"",(string)"",(string)"",(string)"", 0, 0);
			gpib_device->setTimeOut(gpibDeviceTimeOut);	// Set Time Out.
			dev_open = true;
			set_state(Tango::ON);
			set_status("Gpib device is OK.");
            cout << "Device found by name("<< gpibDeviceName<<")." << endl;	    
		} 
		catch (gpibDeviceException f) 
		{
			// Can't open device by or Address. Let commands open / openByName to do it manually.
			cout << "Warning can't open device by name " << gpibDeviceName << " nor with address " << gpibDeviceAddress <<endl;
			if (gpib_device) delete gpib_device;// AJOUT
			set_state(Tango::FAULT);
			set_status("Gpib device is not responding.");
			gpib_device = NULL;
		} 
		catch (...) 
		{
			cout << "UNEXPECTED EXCEPTION !!!" << endl;	
			exit(-1);
		}
	} 
}


//+----------------------------------------------------------------------------
//
// method : 		GpibDeviceServer::readDeviceProperies()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void GpibDeviceServer::get_device_property()
{
	//	Initialize your default values here.
	//------------------------------------------
	gpibDeviceTimeOut = 12; 		/* 3s predefined value 	*/
	gpibDeviceAddress = 0xFF;		/* Unused set to zero	*/
	gpibDeviceName = "UNSPECIFIED";		/* Unused set to zero	*/
	gpibDeviceSecondaryAddress = 0;		/* Unused set to zero	*/
	
	//	Read device properties from database.(Automatic code generation)
	//-------------------------------------------------------------
	Tango::DbData	data;
	data.push_back(Tango::DbDatum("GpibDeviceName"));
	data.push_back(Tango::DbDatum("GpibDeviceAddress"));
	data.push_back(Tango::DbDatum("GpibDeviceTimeOut"));
	data.push_back(Tango::DbDatum("GpibDeviceSecondaryAddress"));
	data.push_back(Tango::DbDatum("GpibBoardName"));

	//	Call database and extract values
	//--------------------------------------------
	get_db_device()->get_property(data);
	if (data[0].is_empty()==false)	data[0]  >>  gpibDeviceName;
	if (data[1].is_empty()==false)	data[1]  >>  gpibDeviceAddress;
	if (data[2].is_empty()==false)	data[2]  >>  gpibDeviceTimeOut;
	if (data[3].is_empty()==false)	data[3]  >>  gpibDeviceSecondaryAddress;
	if (data[4].is_empty()==false)	data[4]  >>  gpibBoardName;


	//	End of Automatic code generation
	//-------------------------------------------------------------
	
	if ( (data[0].is_empty() == true) && (data[1].is_empty() == true) )
	{
		cout << "Mandatory properties 'gpibDeviceName' and 'gpibDeviceAddress' are not defined" << endl;
		cout << "in the Database. Please define at least one of them. Exiting." << endl;
		exit(-1);	    
	}
}
//+----------------------------------------------------------------------------
//
// method : 		GpibDeviceServer::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void GpibDeviceServer::always_executed_hook()
{
    short sb;
	if ( (gpib_device != NULL) && (dev_open == true) ) 
	{
		try 
		{
			sb = gpib_device->isAlive(); 		// Try to get Status byte 
			if (sb != 0)
			{
				set_state(Tango::ON);
				set_status("GPIB Device is On.");
			} 
			else 
			{
				set_state(Tango::FAULT);
				set_status("GPIB Device is Off.");
			}
		} 
		catch (gpibDeviceException e) 
		{
			set_state(Tango::FAULT);
			set_status("GPIB Device is not responding.");
		}
	} 
	else 
	{
		set_state(Tango::OFF);
		set_status("GPIB Device is not controlled by server.");
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::write
 *
 *	description:	method to execute "Write"
 *	This command send a string to the device. Throws devFailed on error.
 *
 * @param	argin	String to send to the device
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::write(Tango::DevString argin)
{
	DEBUG_STREAM << "GpibDeviceServer::write(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to write a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "Write command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to write a not opened device.",
			(const char *) "Device must be open before write operation.",
			Tango::ERR
			);
	}
	
	try 
	{
		gpib_device->write(argin);
	} 
	catch (gpibDeviceException e) 
	{
		
   	    DEBUG_STREAM << "Write command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}	
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::read
 *
 *	description:	method to execute "Read"
 *	This command reads a string from a gpib device. Throws an DevFailed exception on error
 *
 * @return	Returned string.
 *
 */
//+------------------------------------------------------------------
Tango::DevString GpibDeviceServer::read()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevString	argout  = new char[RD_BUFFER_SIZE+1]; // AJOUT +1
	string ret;
	DEBUG_STREAM << "GpibDeviceServer::read(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
		DEBUG_STREAM << "Read command error." << endl;	
		delete[] argout;
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to read a not opened device.",
			(const char *) "Device must be open before read operation.",
			Tango::ERR
			);
	}
	
	try 
	{
		ret = gpib_device->read();
		memset(argout,0, (RD_BUFFER_SIZE+1));   // AJOUT +1
		strcpy(argout, ret.c_str() );
	} 
	catch (gpibDeviceException e) 
	{
   	    DEBUG_STREAM << "Read command error on " << e.getDeviceName() << endl;	
		delete[] argout;
		//cout << "Read error: err="<< e.getErrorValue()<<" state="<< e.getStateValue() << endl;	    
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}	
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::close
 *
 *	description:	method to execute "Close"
 *	Close a previously opened gpib device.
 *	Throws exception on error.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::close()
{
	DEBUG_STREAM << "GpibDeviceServer::close(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )
	{
   	    DEBUG_STREAM << "Close command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to close a not open gpib device.",
			(const char *) "Open the gpib device first.",
			Tango::ERR
			);
	}
	
	try 
	{
		gpib_device->setOffLine();
		if(gpib_device)
		{
			delete gpib_device;
			gpib_device = NULL;
		}
		dev_open = false;
		set_state(Tango::OFF);
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "Close command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}	
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::read_long_string
 *
 *	description:	method to execute "ReadLongString"
 *	For most gpib device the read command is enough to talk with the device. In certain case,
 *	the gpibDevice returns a very big string, which is larger than the read buffer. For concret
 *	example, on :CALC:DATA? command, the hp3588 returns 400 strings representing a
 *	spectrum, for a total size > 4Kbytes. This method reads these sort of long string.
 *	For efficiency, its better to use the read command instead of readLongString. This method
 *	is provided for exceptionnal case. Throws DevFailed on error.
 *
 * @param	argin	Max expected string length.
 * @return	The readed string.
 *
 */
//+------------------------------------------------------------------
Tango::DevString GpibDeviceServer::read_long_string(Tango::DevLong argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevString	argout  = new char[argin];
	string ret;
	DEBUG_STREAM << "GpibDeviceServer::read(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
		delete[] argout;
   	    DEBUG_STREAM << "ReadLongString command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to read a not opened device.",
			(const char *) "Device must be open before read operation.",
			Tango::ERR
			);
	}
	
	try 
	{	
		ret = gpib_device->read(argin);
		strcpy(argout, ret.c_str() );
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "ReadLongString command error on " << e.getDeviceName() << endl;	
		delete[] argout;
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}	
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::get_name
 *
 *	description:	method to execute "GetName"
 *	Return the gpib device name, as define on the gpib Driver (see them with ibconf tool).
 *	Throws DevFailed on error
 *
 * @return	gpib device name
 *
 */
//+------------------------------------------------------------------
Tango::DevString GpibDeviceServer::get_name()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevString	argout  = new char[RD_BUFFER_SIZE+1]; // AJOUT +1
	string ret;
	DEBUG_STREAM << "GpibDeviceServer::get_name(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
		delete[] argout;
   	    DEBUG_STREAM << "getName command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to getName from a not opened device.",
			(const char *) "Device must be open before getName operation.",
			Tango::ERR
			);
	}
	
	try {
		
		ret = gpib_device->getName();
		memset(argout,0, (RD_BUFFER_SIZE+1));  // AJOUT +1  
   	    strcpy(argout, ret.c_str() );
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "getName command error on " << e.getDeviceName() << endl;	
		delete[] argout;
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}	
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::local
 *
 *	description:	method to execute "Local"
 *	Set the gpib device in local mode. Throws DevFailed on error.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::local()
{
	DEBUG_STREAM << "GpibDeviceServer::local(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "Local command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to set a not open device in local mode.",
			(const char *) "Device must be open before using Local command.",
			Tango::ERR
			);
	}
	
	try {
		
		gpib_device->goToLocalMode();
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "Local command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::remote
 *
 *	description:	method to execute "Remote"
 *	Set the gpib device in remote mode. This command is here for compatibility, since
 *	network access to a gpib Device, will automatically turn it to remote mode.
 *	Throws DevFailed on error.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::remote()
{
	DEBUG_STREAM << "GpibDeviceServer::remote(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "Remote command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to set a not open device in remote mode.",
			(const char *) "Device must be open before using Remote command.",
			Tango::ERR
			);
	}
	
	try {
		
		gpib_device->goToRemoteMode();
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "Remote command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::getiberr
 *
 *	description:	method to execute "Getiberr"
 *	This command returns last gpib device error code (lib gpib iberr).
 *	Throws DevFailed on error.
 *
 * @return	no argout
 *
 */
//+------------------------------------------------------------------
Tango::DevLong GpibDeviceServer::getiberr()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "GpibDeviceServer::getiberr(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to get iberr on a non-open device.Generate exception.
	{
   	    DEBUG_STREAM << "getiberr command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to get iberr on a not open device.",
			(const char *) "Device must be open before using getiberr command.",
			Tango::ERR
			);
	}
	
	argout = gpib_device->getiberr(); // This is soft command. No gpibDeviceException here.
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::getibsta
 *
 *	description:	method to execute "Getibsta"
 *	This command returns last gpib device state code (lib gpib ibsta).
 *	Throws DevFailed on error.
 *
 * @return	no argout
 *
 */
//+------------------------------------------------------------------
Tango::DevLong GpibDeviceServer::getibsta()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "GpibDeviceServer::getibsta(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to get iberr on a non-open device.Generate exception.
	{
   	    DEBUG_STREAM << "getibsta command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to get ibsta on a not open device.",
			(const char *) "Device must be open before using getibsta command.",
			Tango::ERR
			);
	}
	argout = gpib_device->getibsta(); // This is soft command. No gpibDeviceException here.
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::getibcnt
 *
 *	description:	method to execute "Getibcnt"
 *	This command returns last gpib device count var (lib gpib ibcnt).
 *	Throws DevFailed on error.
 *
 * @return	no argout
 *
 */
//+------------------------------------------------------------------
Tango::DevULong GpibDeviceServer::getibcnt()
{
	Tango::DevULong	argout ;
	DEBUG_STREAM << "GpibDeviceServer::getibcnt(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to get iberr on a non-open device.Generate exception.
	{
   	    DEBUG_STREAM << "getibcnt command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to get ibcnt on a not open device.",
			(const char *) "Device must be open before using getibcnt command.",
			Tango::ERR
			);
	}
	argout = gpib_device->getibcnt(); // This is soft command. No gpibDeviceException here.
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::clear
 *
 *	description:	method to execute "Clear"
 *	This command clears the gpib device. Throws DevFailed exception on error.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::clear()
{
	DEBUG_STREAM << "GpibDeviceServer::clear(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "Clear command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to clear a not open device.",
			(const char *) "Device must be open before using clear command.",
			Tango::ERR
			);
	}
	
	try {
		
		gpib_device->clear();
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "Clear command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::set_time_out
 *
 *	description:	method to execute "SetTimeOut"
 *	This command set Time Out value for the gpib device.
 *	Warning these values are predefined, cf gpibDevice.h
 *	accepted value are [0-15]. Throws DevFailed exception on error.
 *
 * @param	argin	accepted value are [0-15]
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::set_time_out(Tango::DevShort argin)
{
	DEBUG_STREAM << "GpibDeviceServer::set_time_out(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "SetTimeOut command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to use SetTimeOut on a not open device.",
			(const char *) "Device must be open before using SetTimeOut command.",
			Tango::ERR
			);
	}
	
	try {
		
		gpib_device->setTimeOut(argin);
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "SetTimeOut command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::bcsend_ifc
 *
 *	description:	method to execute "BCsendIFC"
 *	This commands send IFC to the gpib Board0.
 *	So the board becomes Controller In Charge and devices are cleared.
 *	All commands beginning with'BC' are Board Commands.
 *	Throws DevFailed exception on error.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::bcsend_ifc()
{
	DEBUG_STREAM << "GpibDeviceServer::bcsend_ifc(): entering... !" << endl;
	
	//	Add your own code to control device here
	// We don't check that board0 is open since this is done in the init_device method.
	try {
		
		board0->sendIFC();
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "BCsendIFC command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}        
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::bcclr
 *
 *	description:	method to execute "BCclr"
 *	This command clears a specified device.
 *	Throws DevFailed exception on error.
 *
 * @param	argin	handler of the device to clear.
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::bcclr(Tango::DevLong argin)
{
	DEBUG_STREAM << "GpibDeviceServer::bcclr(): entering... !" << endl;
	
	//	Add your own code to control device here
	// We don't check that board0 is open since this is done in the init_device method.
	try {
		
		board0->clr(argin);
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "BCclr command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}        
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::get_device_id
 *
 *	description:	method to execute "GetDeviceID"
 *	This command return internal gpib device ID.
 *	This is usefull for board command using this ID to acces devices, as BCclr cmd.
 *	Throws DevFailed exception on error.
 *
 * @return	no argout
 *
 */
//+------------------------------------------------------------------
Tango::DevLong GpibDeviceServer::get_device_id()
{
	Tango::DevLong	argout ;
	DEBUG_STREAM << "GpibDeviceServer::get_device_id(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to get ID from  a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "getDeviceID command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to get ID from a device not open.",
			(const char *) "Device must be open before getting ID.",
			Tango::ERR
			);
	}
	
	argout = gpib_device->getDeviceID(); // This is soft command. No gpibDeviceException here.
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::bcllo
 *
 *	description:	method to execute "BCllo"
 *	This command send a local lockout to the specified device.
 *	Throws DevFailed exception on error.
 *
 * @param	argin	Device ID
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::bcllo(Tango::DevLong argin)
{
	DEBUG_STREAM << "GpibDeviceServer::bcllo(): entering... !" << endl;
	
	//	Add your own code to control device here
	try {
		
		board0->llo(argin);
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "BCllo command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}        
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::bccmd
 *
 *	description:	method to execute "BCcmd"
 *	Send a GPIB command message.
 *	This method is not used to transmit programming instruction to devices
 *	this kind of instructions are transmitted with the read / write methods.
 *	As done in write method, cmd automatically append EOS, as defined with
 *	setEOS method.
 *
 * @param	argin	Command string.
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::bccmd(Tango::DevString argin)
{
	DEBUG_STREAM << "GpibDeviceServer::bccmd(): entering... !" << endl;
	
	//	Add your own code to control device here
	try {
		
		board0->cmd(argin);
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "BCcmd command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}        
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::open
 *
 *	description:	method to execute "Open"
 *	This command opens a gpib device using the gpibDeviceAddress property.
 *	This command should not be used since gpib device is open on device server initialisation.
 *	Its provided in case of problem to do it manually. Throws DevFailed exception on error.
 *	This command is allowed on fault to accept reconnection.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::open()
{
	DEBUG_STREAM << "GpibDeviceServer::open(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( dev_open )	// Trying to write a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "Open command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to open an already open device.",
			(const char *) "Device must be closed before open operation.",
			Tango::ERR
			);
	}
	
	try {
		
		gpib_device = new gpibDevice( gpibDeviceAddress );
		//	    gpib_device->write("AYT"); 	// Are You There ?
		if (gpib_device->isAlive() )
		{
			dev_open = true;
			set_state(Tango::ON);
			set_status("Gpib device is OK.");
		}
		else
		{
			set_state(Tango::FAULT);
			set_status("Gpib device is not responding.");
			DEBUG_STREAM << "OpenByName command error on " << gpib_device->getName() << endl;	
			Tango::Except::throw_exception(
				(const char *) ("gpibDeviceException on " + gpib_device->getName() ).c_str(),
				(const char *) "Open command error.",
				(const char *) "gpib device is not responding.",
				Tango::ERR
				);	    
		}
	} catch (gpibDeviceException e) {
		
		set_state(Tango::FAULT);
		set_status("Gpib device is not responding.");
   	    if (gpib_device)	
		{
			delete gpib_device; // AJOUT
			gpib_device = NULL;
		}
		DEBUG_STREAM << "Open command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::open_by_name
 *
 *	description:	method to execute "OpenByName"
 *	This command opens a gpib device using the gpibDeviceName property.
 *	This command should not be used since gpib device is opened on device server initialisation.
 *	Its provided in case of problem to do it manually. Throws DevFailed exception on error.
 *	This command is allowed on fault to accept reconnection.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::open_by_name()
{
	DEBUG_STREAM << "GpibDeviceServer::open_by_name(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( dev_open )	// Trying to write a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "OpenByName command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to OpenByName an already open device.",
			(const char *) "Device must be closed before OpenByName operation.",
			Tango::ERR
			);
	}
	
	try {
		
		gpib_device = new gpibDevice( gpibDeviceName );
		//	    gpib_device->write("AYT"); 	// Are You There ?
		
		if (gpib_device->isAlive() )
		{
			dev_open = true;
			set_state(Tango::ON);
			set_status("Gpib device is OK.");
		}
		else
		{
			set_state(Tango::FAULT);
			set_status("Gpib device is not responding.");
			DEBUG_STREAM << "OpenByName command error on " << gpib_device->getName() << endl;	
			Tango::Except::throw_exception(
				(const char *) ("gpibDeviceException on " + gpib_device->getName() ).c_str(),
				(const char *) "Open command error.",
				(const char *) "gpib device is not responding.",
				Tango::ERR
				);	    
		}
	} catch (gpibDeviceException e) {
		
		set_state(Tango::FAULT);
		set_status("Gpib device is not responding.");
   	    if (gpib_device)	
		{
			delete gpib_device; // AJOUT
			gpib_device = NULL;
		}
		DEBUG_STREAM << "OpenByName command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::bcget_connected_device_list
 *
 *	description:	method to execute "BCGetConnectedDeviceList"
 *	This command returns the string array :
 *	
 *	+ primary address + secondary address for 1st device found
 *	
 *	+ primary address + secondary address for 2d device found
 *	ect ....
 *	ex:
 *	HEWLETT-PACKARD,3589A,3343A00642,A.00.03 PAD=6 SAD=0
 *
 * @return	list of connected device on the GPIB bus
 *
 */
//+------------------------------------------------------------------
Tango::DevVarStringArray *GpibDeviceServer::bcget_connected_device_list()
{
	//	Add your own code to control device here
	
	Tango::DevVarStringArray	*argout  = new Tango::DevVarStringArray();
	vector<gpibDeviceInfo> devInfo;
	
	DEBUG_STREAM << "GpibDeviceServer::get_connected_device_list(): entering... !" << endl;	
	
	try {
		
		set_state(Tango::MOVING);
		devInfo = board0->getConnectedDeviceList();
		set_state(Tango::ON);	
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "getConnectedDeviceList command error on " << e.getDeviceName() << endl;	
		delete argout;
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
	
	argout->length(devInfo.size() );
	for (long i = 0; i < devInfo.size(); i++)
	{
		ostringstream os1;
		ostringstream os2;
		
		os1 << devInfo[i].dev_pad;
		string pad = " PAD=" + os1.str();
		
		os2 << devInfo[i].dev_sad;
		string sad = " SAD=" + os2.str();
		(*argout)[i] = CORBA::string_dup( (devInfo[i].dev_idn + pad + sad  ).c_str() );
	}
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::trigger
 *
 *	description:	method to execute "Trigger"
 *	This command sends a trigger signal to the GPIB device.
 *	If the device was previously set up, it can make its measurment, and send it on the bus.
 *	Measure is now get with a read command.
 *
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::trigger()
{
	DEBUG_STREAM << "GpibDeviceServer::trigger(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "Trigger command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to Trigger a not open device.",
			(const char *) "Device must be open before using Trigger command.",
			Tango::ERR
			);
	}
	
	try {
		
		gpib_device->trigger();
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "Trigger command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::write_read
 *
 *	description:	method to execute "WriteRead"
 *	This command perform a write on the GPIB device, and then perform a read to
 *	get the answer, before returning it.
 *
 * @param	argin	String to send to the gpib device.
 * @return	String returned by the gpib Device.
 *
 */
//+------------------------------------------------------------------
Tango::DevString GpibDeviceServer::write_read(Tango::DevString argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevString	argout  = new char[RD_BUFFER_SIZE+1]; // AJOUT +1
	string ret;
	
	DEBUG_STREAM << "GpibDeviceServer::write_read(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to write a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "WriteRead command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to write a not opened device.",
			(const char *) "Device must be open before write operation.",
			Tango::ERR
			);
	}
	
	try {
		
		ret = gpib_device->writeRead(argin);
		memset(argout,0, (RD_BUFFER_SIZE+1));  // AJOUT +1 
   	    strcpy(argout, ret.c_str() );
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "WriteRead command error on " << e.getDeviceName() << endl;	
		delete[] argout;
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}	
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::config
 *
 *	description:	method to execute "Config"
 *	index 0 of input array is the GPIB option to modify.
 *	index 1 is the new value to associate to this option.
 *
 * @param	argin	Array of 2 long.
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::config(const Tango::DevVarLongArray *argin)
{
	DEBUG_STREAM << "GpibDeviceServer::config(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to write a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "WriteRead command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to write a not opened device.",
			(const char *) "Device must be open before write operation.",
			Tango::ERR
			);
	}
	
	// Check parameter number.
	if (argin->length() != 2) {
		
		DEBUG_STREAM << "GpibDeviceServer::bcconfig(): Wrong input parameter number." << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + gpib_device->getName() ).c_str(),
			(const char *) "GpibDeviceServer::bcconfig(): Wrong input parameter number.",
			(const char *) "Two parameters are needed.",
			Tango::ERR
			);
	} 
	
	try {
		
		gpib_device->config( (*argin)[0], (*argin)[1]);
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "Config command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	} 
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::bcconfig
 *
 *	description:	method to execute "BCConfig"
 *	Same method than Config, but sent on gpib Board instead of GPIB device.
 *
 * @param	argin	Array of 2 long.
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::bcconfig(const Tango::DevVarLongArray *argin)
{
	DEBUG_STREAM << "GpibDeviceServer::bcconfig(): entering... !" << endl;
	
	//	Add your own code to control device here
	
	if (argin->length() != 2) {
		
		DEBUG_STREAM << "GpibDeviceServer::bcconfig(): Wrong input parameter number." << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + gpib_device->getName() ).c_str(),
			(const char *) "GpibDeviceServer::bcconfig(): Wrong input parameter number.",
			(const char *) "Two parameters are needed.",
			Tango::ERR
			);
	} 
	
	try {
		
		board0->config( (*argin)[0], (*argin)[1]);
		
	} catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "BCConfig command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char *) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char *) e.getiberrMessage().c_str(),
			(const char *) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}        
}

//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::send_bin_data
 *
 *	description:	method to execute "SendBinData"
 *	This command send an array of binary data to the device through the GPIB bus.
 *	Throws devFailed on error.
 *
 * @param	argin	Array of binary data to send to the device
 *
 */
//+------------------------------------------------------------------
void GpibDeviceServer::send_bin_data(const Tango::DevVarCharArray *argin)
{
	DEBUG_STREAM << "GpibDeviceServer::send_bin_data(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to write a non-open device. Generate exception.
	{
   	    DEBUG_STREAM << "send_bin_data command error." << endl;	
		Tango::Except::throw_exception(
			(const char *) "gpibDeviceException.",
			(const char *) "Attempt to send data on a not opened device.",
			(const char *) "Device must be open before write operation.",
			Tango::ERR
			);
	}
	
	char *data =  new char[argin->length()];
	// check if memory is allocated
	if (data == NULL)
	{
   	    DEBUG_STREAM << "send_bin_data can not allocate memory." << endl;	
		Tango::Except::throw_exception(
			(const char*) "gpibDeviceException.",
			(const char*) "memory not allocated.",
			(const char*) "malloc() in send_bin_data().",
			Tango::ERR
			);
	}
	
	// sendData expected a char* and not a Tango::DevVarCharArray *
	for(int i = 0; i < argin->length(); i++)
		data[i] = (*argin)[i];
	
	try {
		
		gpib_device->sendData(data, argin->length());
		delete[] data;
	} 
	catch (gpibDeviceException e) {
		
   	    if(data) delete[] data;
		DEBUG_STREAM << "send_bin_data command error on " << e.getDeviceName() << endl;	
		Tango::Except::throw_exception(
			(const char*) ("gpibDeviceException on " + e.getDeviceName() ).c_str(),
			(const char*) e.getiberrMessage().c_str(),
			(const char*) e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}	
	catch(...)
	{
   	    if(data) delete[] data;
   	    FATAL_STREAM << "send_bin_data catch(...) case " << endl;	
	}
}


//+------------------------------------------------------------------
/**
 *	method:	GpibDeviceServer::receive_bin_data
 *
 *	description:	method to execute "ReceiveBinData"
 *	This command reads an array of binary data from a gpib device.
 *	Up to 65536 bytes. In generaly, a Gpib device can send or receive 64Ko.
 *	Throws an DevFailed exception on error
 *
 * @param	argin	length of the data to receive from the Gpib device
 * @return	Array of binary data
 *
 */
//+------------------------------------------------------------------
Tango::DevVarCharArray *GpibDeviceServer::receive_bin_data(Tango::DevUShort argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	DEBUG_STREAM << "GpibDeviceServer::receive_bin_data(): entering... !" << endl;
	
	//	Add your own code to control device here
	if ( !dev_open )	// Trying to read a non-open device. Generate exception.
	{
		DEBUG_STREAM << "receive_bin_data command error." << endl;	
		Tango::Except::throw_exception(
			(const char*) "gpibDeviceException.",
			(const char*) "Attempt to read data from a not opened device.",
			(const char*) "Device must be open before read operation.",
			Tango::ERR
			);
	}
	
	short nb_data = argin;
	char	*response;
	
	try {
		
		response = gpib_device->receiveData(nb_data);
		
	} 
	catch (gpibDeviceException e) {
		
   	    DEBUG_STREAM << "receive_bin_data command error on " << e.getDeviceName() << endl;	
		//if (argout) delete argout;
		Tango::Except::throw_exception(
			(const char*)(("gpibDeviceException on " + e.getDeviceName() ).c_str()),
			(const char*)e.getiberrMessage().c_str(),
			(const char*)e.getibstaMessage().c_str(),
			Tango::ERR
			);
	}
	
	Tango::DevVarCharArray *argout = new Tango::DevVarCharArray();
	argout->length(nb_data);
	
	// check if memory is allocated
	if (argout == NULL)
	{
   	    DEBUG_STREAM << "receive_bin_data can not allocate memory." << endl;	
		Tango::Except::throw_exception(
			(const char*) "gpibDeviceException.",
			(const char*) "memory not allocated.",
			(const char*) "new Tango::DevVarCharArray() failed in receive_bin_data().",
			Tango::ERR
			);
	}
	
	for (int i = 0; i < nb_data; i++)
		(*argout)[i] = response[i];
	
	delete [] response;
	
	return argout;
}

}	//	namespace
